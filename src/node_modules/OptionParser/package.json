{
  "name": "OptionParser",
  "version": "0.1.1",
  "author": {
    "name": "Tyler Akins",
    "email": "fidian@rumkin.com"
  },
  "description": "Command-line option parser similar to getopt",
  "homepage": "https://github.com/fidian/OptionParser/",
  "contributors": [
    {
      "name": "Tyler Akins",
      "email": "fidian@rumkin.com",
      "url": "http://rumkin.com/"
    }
  ],
  "main": "./nodejs/OptionParser.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/fidian/OptionParser.git"
  },
  "keywords": [
    "command-line",
    "command",
    "line",
    "option",
    "parser",
    "flag",
    "flags",
    "getopt"
  ],
  "dependencies": {},
  "devDependencies": {},
  "license": "MIT",
  "engines": {
    "node": ">=0.6",
    "npm": "~1"
  },
  "scripts": {
    "test": "cd tests && node nodejs.js"
  },
  "readme": "OptionParser is a library to help you parse command-line options, similar to\nhow getopt works.  An effort is made to make it POSIX compliant and easy for\npeople to use.  Features of many other implementations have been integrated in\norder to provide significant flexibility and to make it easier to use.\n\nExamples in this guide are written in PHP, but it is easy to translate that\nacross to JavaScript.  The syntax is nearly identical.  There are also sample\nparsers in the [examples] directory in the repository for both languages.\n\nTravis CI [![build status](https://secure.travis-ci.org/fidian/OptionParser.png)](http://travis-ci.org/fidian/OptionParser)\n\nFeatures\n========\n* -x (short options)\n* -xxxyxxz (combined and repeating short options)\n* --long (long option)\n* -x=Value, --long=Value (optional and required values)\n* -xValue --long Value (special format for required values)\n* -- (signify the end of options)\n* Can stop on the first unparsed option\n* Can autocomplete long options\n* Returns unparsed options\n* Flexible option handling\n\nLanguages Supported\n===================\n\n* PHP - http://php.net\n* JavaScript via node.js - http://nodejs.org/\n\nHow to use\n==========\n\nFirst, create the parser object:\n\n    $parser = new OptionParser();\n\nNext, you add some options.  I'll jump right in and add the standard \"help\"\noption, triggered with either -h or --help.\n\n    $parser->addOption('h', 'help', 'Display this help message')\n        ->action($parser->helpAction());\n\nFinally, parse the command line options.\n\n    $parser->parse();\n\nHow To Use Parameters\n=====================\n\nThe whole point of the library is to make it really easy to handle the parsing\nof options to your program.  Let's run through a few examples here:\n\nToggle a Flag With A Callback\n-----------------------------\n\nIn PHP you can pass more than just callbacks; names of functions, an array with\nthe class name and method, and anything else that works with call_user_func().\nFor JavaScript, this only works for closures.  Let's have this option only work\nwith the short option \"-f\".\n\n    $flagWasSet = false;\n\n    $parser->addOption('f', null, 'Toggle a flag')\n        ->action(function () use (&$flagWasSet) {\n            $flagWasSet = true;\n        });\n\nPass a Required Value\n---------------------\n\nMany options need a specific value, such as an input file to process.  Here is\nanother option that is specified by \"-i\" or \"--input\" that requires a filename\nof the input file.  It uses a callback, just like the above example.\n\n    $inputFile = 'php://stdin';\n\n    $parser->addOption('i', 'input', 'Specify an input file')\n        ->argument('FILE')  // You can name the argument anything you like\n        ->action(function ($value) use (&$inputFile) {\n            $inputFile = $value;\n        });\n\nOptional Value and Parameter Object\n-----------------------------------\n\nClosures in PHP are not quite the same as JavaScript since you need to\nexplicitly list the variables that are in scope for the execution of the\nfunction.  An alternative would be to use the returned object from setting up\nthe option on the parser.  Here, we add a debug option that lets you set the\ndebug level, but can default to 5 if you don't set one explicitly.\n\n    $debugLevel = 0;\n\n    $debugOption = $parser->addOption(null, 'debug',\n         'Sets the debug level; if set, default is 5')\n        ->argument('Level', false);  // See note below\n\n    // Don't forget to set up the other options here\n\n    $parser->parse();\n    \n    // Now use the $debugOption object to set the debug value\n    if ($debugOption->count()) {\n        $debugLevel = $debugOption->value();\n    }\n\nThe first parameter to OptionParameter->argument() is the name of the\nparameter, as seen in the generated help message.  It doesn't affect the\nexecution of the parser in any other way.  The second parameter, false,\nmakes the argument optional.\n\n$debugOption->count() returns the number of times the argument was specified.\n$debugOption->value() returns the last value passed to the parameter.  For\ndetailed information, check out the documentation for [OptionParameter].\n\nNamed Parameters\n----------------\n\nKeeping references to the objects can be tedious.  Here is the above example\naltered to name the parameter and then use the named parameter.  I'm naming the\nparameter \"dddd\" to help contrast against the previous code.\n\n    $debugLevel = 0;\n\n    $parser->addOption(null, 'debug',\n         'Sets the debug level, default is 5', 'dddd')\n        ->argument('Level', false);\n\n    // Don't forget to set up the other options here\n\n    $parser->parse();\n    \n    if ($parser->dddd->count()) {\n        $debugLevel = $parser->dddd->value();\n    }\n\nGetopt\n------\n\nLastly, PHP has a unique format for handling command-line arguments using\nthe built-in function getopt().  After setting up options and calling\n$parser->parse(), you can get back an array that mimics getopt()'s return\nvalue.  This should make it easier to plug this parser into your code and\nbenefit from the better option handling without retooling anything after the\ncall to getopt() that you'd normally make.\n\n    // Set up options and then call parse()\n    $parser->parse();\n\n    // Get back an array of options like PHP's getopt()\n    $options = $parser->getopt();\n\nUnparsed Options\n================\n\nIf you plan on making a program that takes a list of files or needs to work on\nthe options that were passed to the program but were not parsed by\nOptionParser, that's really simple:\n\n    $unparsed = $parser->parse();\n\nThis will contain an array of options, split out into individual options.  If\nyou passed \"-abcd\" to your program and it handled \"-a\", \"-b\", and \"-c\", then\n$unparsed would be an array that only contains \"-d\".\n\nMore Reading\n============\n\nYou can read the documentation for the individual classes to understand more\nabout what they do and how they work.\n\n* [OptionParameter]\n* [OptionParser]\n\nReference implementations are available in the [examples] directory in the\nrepository.\n\n[OptionParameter]: https://github.com/fidian/OptionParser/blob/master/OptionParameter.md\n[OptionParser]: https://github.com/fidian/OptionParser/blob/master/OptionParser.md\n[examples]: https://github.com/fidian/OptionParser/tree/master/examples/\n",
  "readmeFilename": "README.md",
  "_id": "OptionParser@0.1.1",
  "dist": {
    "shasum": "d33f6a790c2cd66f62c567fcc1b7d01d735f37ec"
  },
  "_from": "OptionParser"
}
